/* ============================================================
   BossMind Alerts Worker v3 (Automation-Lock Aware)
   - Sends queued alerts from bm_alert_outbox to Telegram
   - Respects bm_is_locked (pauses sending when locked)
   ============================================================ */

'use strict';

const { createClient } = require('@supabase/supabase-js');

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID;

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
  throw new Error('Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY');
}
if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) {
  throw new Error('Missing TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID');
}

const WORKER_ID =
  process.env.BOSSMIND_ALERTS_WORKER_ID ||
  `alerts-${process.pid}-${Math.random().toString(36).slice(2, 8)}`;

const POLL_INTERVAL_MS = Number(process.env.BOSSMIND_ALERTS_POLL_INTERVAL_MS || 2000);
const BATCH_SIZE = Number(process.env.BOSSMIND_ALERTS_BATCH_SIZE || 10);
const MAX_SEND_PER_CYCLE = Number(process.env.BOSSMIND_ALERTS_MAX_SEND_PER_CYCLE || 10);

const LOCK_CACHE_TTL_MS = Number(process.env.BOSSMIND_LOCK_CACHE_TTL_MS || 2000);
let _lockCache = { locked: false, ts: 0 };

let SHUTTING_DOWN = false;

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
  auth: { persistSession: false },
});

async function main() {
  log(`Booted. worker_id=${WORKER_ID}`);

  while (!SHUTTING_DOWN) {
    const locked = await isAutomationLocked();
    if (locked) {
      log('Automation is LOCKED. Pausing alerts worker.');
      await sleep(Math.max(POLL_INTERVAL_MS, 2500));
      continue;
    }

    try {
      const alerts = await fetchQueuedAlerts(BATCH_SIZE);
      if (!alerts.length) {
        await sleep(POLL_INTERVAL_MS);
        continue;
      }

      let sentCount = 0;

      for (const alert of alerts) {
        if (SHUTTING_DOWN) break;
        if (sentCount >= MAX_SEND_PER_CYCLE) break;

        if (String(alert.channel).toLowerCase() !== 'telegram') {
          await markFailed(alert.id, `Unsupported channel in this worker: ${alert.channel}`);
          continue;
        }

        try {
          const toChat = alert.to_address || TELEGRAM_CHAT_ID;
          const subject = alert.subject ? `*${escapeMarkdown(alert.subject)}*\n` : '';
          const msg = `${subject}${escapeMarkdown(alert.message || '')}`;

          await sendTelegram(toChat, msg);
          await markSent(alert.id);
          sentCount++;
          log(`Sent alert id=${alert.id}`);
        } catch (err) {
          const errTxt = truncateErr(err);
          await markFailed(alert.id, errTxt);
          logError(err);
        }
      }
    } catch (err) {
      logError(err);
      await sleep(1000);
    }
  }

  log('Shutdown complete.');
}

// -----------------------
// Lock state
// -----------------------
async function isAutomationLocked() {
  const now = Date.now();
  if (now - _lockCache.ts < LOCK_CACHE_TTL_MS) return _lockCache.locked;

  try {
    const { data, error } = await supabase.rpc('bm_is_locked');
    if (error) throw error;
    const locked = Boolean(data);
    _lockCache = { locked, ts: now };
    return locked;
  } catch (e) {
    // Fail-safe pause
    _lockCache = { locked: true, ts: now };
    log(`Lock check failed; pausing for safety. (${String(e?.message || e)})`);
    return true;
  }
}

// -----------------------
// DB ops
// -----------------------
async function fetchQueuedAlerts(limit) {
  const { data, error } = await supabase
    .from('bm_alert_outbox')
    .select('id, channel, to_address, subject, message, status, created_at')
    .eq('status', 'queued')
    .order('created_at', { ascending: true })
    .limit(limit);

  if (error) throw error;
  return Array.isArray(data) ? data : [];
}

async function markSent(id) {
  const { error } = await supabase
    .from('bm_alert_outbox')
    .update({ status: 'sent', sent_at: new Date().toISOString(), last_error: null })
    .eq('id', id);

  if (error) throw error;
}

async function markFailed(id, errText) {
  const { error } = await supabase
    .from('bm_alert_outbox')
    .update({
      status: 'failed',
      last_error: String(errText || 'unknown error').slice(0, 4000),
    })
    .eq('id', id);

  if (error) throw error;
}

// -----------------------
// Telegram
// -----------------------
async function sendTelegram(chatId, text) {
  const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;

  const res = await fetch(url, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({
      chat_id: chatId,
      text,
      parse_mode: 'MarkdownV2',
      disable_web_page_preview: true,
    }),
  });

  if (!res.ok) {
    const body = await safeReadText(res);
    throw new Error(`Telegram send failed: HTTP ${res.status} ${body}`);
  }
}

async function safeReadText(res) {
  try {
    return await res.text();
  } catch {
    return '';
  }
}

// -----------------------
// Signals
// -----------------------
process.on('SIGINT', shutdown);
process.on('SIGTERM', shutdown);
process.on('uncaughtException', (err) => logError(err));
process.on('unhandledRejection', (err) => logError(err));

function shutdown() {
  if (SHUTTING_DOWN) return;
  SHUTTING_DOWN = true;
  log('Shutdown signal received...');
}

// -----------------------
// Helpers
// -----------------------
function sleep(ms) {
  return new Promise((res) => setTimeout(res, ms));
}

function truncateErr(err) {
  const msg = err && err.stack ? err.stack : err && err.message ? err.message : String(err);
  return msg.slice(0, 4000);
}

function log(msg) {
  console.log(`[BossMind-Alerts][${new Date().toISOString()}] ${msg}`);
}

function logError(err) {
  console.error(
    `[BossMind-Alerts][${new Date().toISOString()}][ERROR]`,
    err && err.stack ? err.stack : err
  );
}

function escapeMarkdown(s) {
  return String(s || '').replace(/([_*\[\]()~`>#+\-=|{}.!\\])/g, '\\$1');
}

// Start
main().catch((e) => {
  logError(e);
  process.exit(1);
});
